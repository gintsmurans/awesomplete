!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define([],I):"object"==typeof exports?exports.Awesomplete=I():g.Awesomplete=I()}(window,function(){return function(g){var I={};function C(A){if(I[A])return I[A].exports;var n=I[A]={i:A,l:!1,exports:{}};return g[A].call(n.exports,n,n.exports,C),n.l=!0,n.exports}return C.m=g,C.c=I,C.d=function(g,I,A){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:A})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var A=Object.create(null);if(C.r(A),Object.defineProperty(A,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var n in g)C.d(A,n,function(I){return g[I]}.bind(null,n));return A},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Awesomplete; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Simple, lightweight, usable local autocomplete library for modern browsers\n * Because there weren’t enough autocomplete scripts in the world?\n * Because I’m completely insane and have NIH syndrome? Probably both. :P\n * @author Lea Verou http://leaverou.github.io/awesomplete\n * MIT license\n */\n\n/** Class representing a single Suggesstion. */\nvar Suggestion =\n/*#__PURE__*/\nfunction () {\n  function Suggestion(data) {\n    _classCallCheck(this, Suggestion);\n\n    var o = {\n      label: 'Unknown data',\n      value: 'Unknown data'\n    };\n\n    if (typeof data === 'string') {\n      o = {\n        label: data,\n        value: data\n      };\n    } else if (Array.isArray(data)) {\n      o = {\n        label: data[0],\n        value: data[1]\n      };\n    } else if (_typeof(data) === 'object' && ('label' in data || 'value' in data)) {\n      o = data;\n    }\n\n    this.label = o.label || o.value;\n    this.value = o.value;\n\n    if ('userData' in o) {\n      this.userData = o.userData;\n    }\n  }\n\n  _createClass(Suggestion, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.label);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toString();\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.label.length;\n    }\n  }]);\n\n  return Suggestion;\n}();\n/** Class representing Awesomplete. */\n\n\nvar Awesomplete =\n/*#__PURE__*/\nfunction () {\n  function Awesomplete(input, o) {\n    _classCallCheck(this, Awesomplete);\n\n    Awesomplete.all = [];\n    var me = this; // Keep track of number of instances for unique IDs\n\n    Awesomplete.count = (Awesomplete.count || 0) + 1;\n    this.count = Awesomplete.count; // Setup\n\n    this.isOpened = false;\n    this.input = Awesomplete.query(input);\n    this.input.setAttribute('autocomplete', 'off');\n    this.input.setAttribute('aria-owns', \"awesomplete_list_\".concat(this.count));\n    this.input.setAttribute('role', 'combobox'); // store constructor options in case we need to distinguish\n    // between default and customized behavior later on\n\n    this.options = o || {};\n    this.configure({\n      minChars: 2,\n      maxItems: 10,\n      autoFirst: false,\n      data: Awesomplete.DATA,\n      filter: Awesomplete.FILTER_CONTAINS,\n      sort: o.sort === false ? false : Awesomplete.SORT_BYLENGTH,\n      container: Awesomplete.CONTAINER,\n      item: Awesomplete.ITEM,\n      replace: Awesomplete.REPLACE,\n      tabSelect: false\n    }, o);\n    this.index = -1; // Create necessary elements\n\n    this.container = this.container(input);\n    this.ul = Awesomplete.create('ul', {\n      hidden: 'hidden',\n      role: 'listbox',\n      id: \"awesomplete_list_\".concat(this.count),\n      inside: this.container\n    });\n    this.status = Awesomplete.create('span', {\n      className: 'visually-hidden',\n      role: 'status',\n      'aria-live': 'assertive',\n      'aria-atomic': true,\n      inside: this.container,\n      textContent: this.minChars !== 0 ? \"Type \".concat(this.minChars, \" or more characters for results.\") : 'Begin typing for results.'\n    }); // Bind events\n\n    this.events = {\n      input: {\n        input: this.evaluate.bind(this),\n        blur: this.close.bind(this, {\n          reason: 'blur'\n        }),\n        keydown: function keydown(evt) {\n          var c = evt.keyCode; // If the dropdown `ul` is in view, then act on keydown for the following keys:\n          // Enter / Esc / Up / Down\n\n          if (me.opened) {\n            if (c === 13 && me.selected) {\n              // Enter\n              evt.preventDefault();\n              me.select();\n            } else if (c === 9 && me.selected && me.tabSelect) {\n              me.select();\n            } else if (c === 27) {\n              // Esc\n              me.close({\n                reason: 'esc'\n              });\n            } else if (c === 38 || c === 40) {\n              // Down/Up arrow\n              evt.preventDefault();\n              me[c === 38 ? 'previous' : 'next']();\n            }\n          }\n        }\n      },\n      form: {\n        submit: this.close.bind(this, {\n          reason: 'submit'\n        })\n      },\n      ul: {\n        // Prevent the default mousedowm, which ensures the input is not blurred.\n        // The actual selection will happen on click. This also ensures dragging the\n        // cursor away from the list item will cancel the selection\n        mousedown: function mousedown(evt) {\n          evt.preventDefault();\n        },\n        // The click event is fired even if the corresponding mousedown event has called\n        // preventDefault\n        click: function click(evt) {\n          var li = evt.target;\n\n          if (li !== this) {\n            while (li && !/li/i.test(li.nodeName)) {\n              li = li.parentNode;\n            }\n\n            if (li && evt.button === 0) {\n              // Only select on left click\n              evt.preventDefault();\n              me.select(li, evt.target);\n            }\n          }\n        }\n      }\n    };\n    Awesomplete.bind(this.input, this.events.input);\n    Awesomplete.bind(this.input.form, this.events.form);\n    Awesomplete.bind(this.ul, this.events.ul);\n\n    if (this.input.hasAttribute('list')) {\n      this.list = \"#\".concat(this.input.getAttribute('list'));\n      this.input.removeAttribute('list');\n    } else {\n      this.list = this.input.getAttribute('data-list') || o.list || [];\n    }\n\n    Awesomplete.all.push(this);\n  }\n\n  _createClass(Awesomplete, [{\n    key: \"configure\",\n    value: function configure(properties, o) {\n      var _this = this;\n\n      var iterFn = function iterFn(i) {\n        var initial = properties[i];\n\n        var attrValue = _this.input.getAttribute(\"data-\".concat(i.toLowerCase()));\n\n        if (typeof initial === 'number') {\n          _this[i] = parseInt(attrValue, 10);\n        } else if (initial === false) {\n          // Boolean options must be false by default anyway\n          _this[i] = attrValue !== null;\n        } else if (initial instanceof Function) {\n          _this[i] = null;\n        } else {\n          _this[i] = attrValue;\n        }\n\n        if (!_this[i] && _this[i] !== 0) {\n          _this[i] = i in o ? o[i] : initial;\n        }\n      };\n\n      Object.keys(properties).forEach(iterFn);\n    }\n  }, {\n    key: \"close\",\n    value: function close(o) {\n      if (!this.opened) {\n        return;\n      }\n\n      this.ul.setAttribute('hidden', '');\n      this.isOpened = false;\n      this.index = -1;\n      this.status.setAttribute('hidden', '');\n      Awesomplete.fire(this.input, 'awesomplete-close', o || {});\n    }\n  }, {\n    key: \"open\",\n    value: function open() {\n      this.ul.removeAttribute('hidden');\n      this.isOpened = true;\n      this.status.removeAttribute('hidden');\n\n      if (this.autoFirst && this.index === -1) {\n        this.goto(0);\n      }\n\n      Awesomplete.fire(this.input, 'awesomplete-open');\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      // remove events from the input and its form\n      Awesomplete.unbind(this.input, this.events.input);\n      Awesomplete.unbind(this.input.form, this.events.form); // cleanup container if it was created by Awesomplete but leave it alone otherwise\n\n      if (!this.options.container) {\n        // move the input out of the awesomplete container and remove the container and\n        // its children\n        var parentNode = this.container.parentNode;\n        parentNode.insertBefore(this.input, this.container);\n        parentNode.removeChild(this.container);\n      } // remove autocomplete and aria-autocomplete attributes\n\n\n      this.input.removeAttribute('autocomplete');\n      this.input.removeAttribute('aria-autocomplete'); // remove this awesomeplete instance from the global array of instances\n\n      var indexOfAwesomplete = Awesomplete.all.indexOf(this);\n\n      if (indexOfAwesomplete !== -1) {\n        Awesomplete.all.splice(indexOfAwesomplete, 1);\n      }\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var count = this.ul.children.length;\n      var index = 0;\n\n      if (this.index < count - 1) {\n        index = this.index + 1;\n      } else if (count) {\n        index = 0;\n      } else {\n        index = -1;\n      }\n\n      this.goto(index);\n    }\n  }, {\n    key: \"previous\",\n    value: function previous() {\n      var count = this.ul.children.length;\n      var pos = this.index - 1;\n      this.goto(this.selected && pos !== -1 ? pos : count - 1);\n    } // Should not be used, highlights specific item without any checks!\n\n  }, {\n    key: \"goto\",\n    value: function goto(i) {\n      var lis = this.ul.children;\n\n      if (this.selected) {\n        lis[this.index].setAttribute('aria-selected', 'false');\n      }\n\n      this.index = i;\n\n      if (i > -1 && lis.length > 0) {\n        lis[i].setAttribute('aria-selected', 'true');\n        this.status.textContent = \"\".concat(lis[i].textContent, \", list item \").concat(i + 1, \" of \").concat(lis.length);\n        this.input.setAttribute('aria-activedescendant', \"\".concat(this.ul.id, \"_item_\").concat(this.index)); // scroll to highlighted element in case parent's height is fixed\n\n        this.ul.scrollTop = lis[i].offsetTop - this.ul.clientHeight + lis[i].clientHeight;\n        Awesomplete.fire(this.input, 'awesomplete-highlight', {\n          text: this.suggestions[this.index]\n        });\n      }\n    }\n  }, {\n    key: \"select\",\n    value: function select(selected, origin) {\n      var selectedItem = selected;\n\n      if (selected) {\n        this.index = Awesomplete.siblingIndex(selected);\n      } else {\n        selectedItem = this.ul.children[this.index];\n      }\n\n      if (selectedItem) {\n        var suggestion = this.suggestions[this.index];\n        var selectedIndex = this.index;\n        var allowed = Awesomplete.fire(this.input, 'awesomplete-select', {\n          text: \"\".concat(suggestion),\n          selectedIndex: selectedIndex,\n          selectedSuggestion: suggestion,\n          origin: origin || selectedItem\n        });\n\n        if (allowed) {\n          this.replace(suggestion);\n          this.close({\n            reason: 'select'\n          });\n          Awesomplete.fire(this.input, 'awesomplete-selectcomplete', {\n            text: \"\".concat(suggestion),\n            selectedIndex: selectedIndex,\n            selectedSuggestion: suggestion\n          });\n        }\n      }\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate() {\n      var me = this;\n      var value = this.input.value;\n\n      if (value.length >= this.minChars && this.dataList && this.dataList.length > 0) {\n        this.index = -1; // Populate list with options that match\n\n        this.ul.innerHTML = '';\n\n        var mapFn = function mapFn(item) {\n          return new Suggestion(me.data(item, value));\n        };\n\n        var filterFn = function filterFn(item) {\n          return me.filter(item, value);\n        };\n\n        this.suggestions = this.dataList.map(mapFn).filter(filterFn);\n\n        if (this.sort !== false) {\n          this.suggestions = this.suggestions.sort(this.sort);\n        }\n\n        this.suggestions = this.suggestions.slice(0, this.maxItems);\n\n        var appendFn = function appendFn(text, index) {\n          me.ul.appendChild(me.item(text, value, index));\n        };\n\n        this.suggestions.forEach(appendFn);\n\n        if (this.ul.children.length === 0) {\n          this.status.textContent = 'No results found';\n          this.close({\n            reason: 'nomatches'\n          });\n        } else {\n          this.open();\n          this.status.textContent = \"\".concat(this.ul.children.length, \" results found\");\n        }\n      } else {\n        this.close({\n          reason: 'nomatches'\n        });\n        this.status.textContent = 'No results found';\n      }\n    } // Mark: Static methods/properties\n\n  }, {\n    key: \"list\",\n    set: function set(list) {\n      if (Array.isArray(list)) {\n        this.dataList = list;\n      } else if (typeof list === 'string' && list.indexOf(',') > -1) {\n        this.dataList = list.split(/\\s*,\\s*/);\n      } else {\n        // Element or CSS selector\n        var queriedList = Awesomplete.query(list);\n\n        if (queriedList && queriedList.children) {\n          var items = [];\n\n          var fn = function fn(el) {\n            if (!el.disabled) {\n              var text = el.textContent.trim();\n              var value = el.value || text;\n              var label = el.label || text;\n\n              if (value !== '') {\n                items.push({\n                  label: label,\n                  value: value\n                });\n              }\n            }\n          };\n\n          Array.prototype.slice.apply(queriedList.children).forEach(fn);\n          this.dataList = items;\n        }\n      }\n\n      if (document.activeElement === this.input) {\n        this.evaluate();\n      }\n    },\n    get: function get() {\n      return this.dataList;\n    }\n  }, {\n    key: \"selected\",\n    get: function get() {\n      return this.index > -1;\n    }\n  }, {\n    key: \"opened\",\n    get: function get() {\n      return this.isOpened;\n    }\n  }], [{\n    key: \"FILTER_CONTAINS\",\n    value: function FILTER_CONTAINS(text, input) {\n      return RegExp(Awesomplete.regExpEscape(input.trim()), 'i').test(text);\n    }\n  }, {\n    key: \"FILTER_STARTSWITH\",\n    value: function FILTER_STARTSWITH(text, input) {\n      return RegExp(\"^\".concat(Awesomplete.regExpEscape(input.trim())), 'i').test(text);\n    }\n  }, {\n    key: \"SORT_BYLENGTH\",\n    value: function SORT_BYLENGTH(a, b) {\n      if (a.length !== b.length) {\n        return a.length - b.length;\n      }\n\n      return a < b ? -1 : 1;\n    }\n  }, {\n    key: \"CONTAINER\",\n    value: function CONTAINER(input) {\n      return Awesomplete.create('div', {\n        className: 'awesomplete',\n        around: input\n      });\n    }\n  }, {\n    key: \"ITEM\",\n    value: function ITEM(text, input, itemId) {\n      var html = input.trim() === '' ? text : \"\".concat(text).replace(RegExp(Awesomplete.regExpEscape(input.trim()), 'gi'), '<mark>$&</mark>');\n      return Awesomplete.create('li', {\n        innerHTML: html,\n        'aria-selected': 'false',\n        id: \"awesomplete_list_\".concat(this.count, \"_item_\").concat(itemId)\n      });\n    }\n  }, {\n    key: \"REPLACE\",\n    value: function REPLACE(text) {\n      this.input.value = text.value || text.label;\n    }\n  }, {\n    key: \"DATA\",\n    value: function DATA(item\n    /* , input */\n    ) {\n      return item;\n    } // Helpers\n\n  }, {\n    key: \"query\",\n    value: function query(expr, con) {\n      return typeof expr === 'string' ? (con || document).querySelector(expr) : expr || null;\n    }\n  }, {\n    key: \"queryAll\",\n    value: function queryAll(expr, con) {\n      return Array.prototype.slice.call((con || document).querySelectorAll(expr));\n    }\n  }, {\n    key: \"create\",\n    value: function create(tag, o) {\n      var element = document.createElement(tag);\n\n      var iterFn = function iterFn(i) {\n        var val = o[i];\n\n        if (i === 'inside') {\n          Awesomplete.query(val).appendChild(element);\n        } else if (i === 'around') {\n          var ref = Awesomplete.query(val);\n          ref.parentNode.insertBefore(element, ref);\n          element.appendChild(ref);\n\n          if (ref.getAttribute('autofocus') != null) {\n            ref.focus();\n          }\n        } else if (i in element) {\n          element[i] = val;\n        } else {\n          element.setAttribute(i, val);\n        }\n      };\n\n      Object.keys(o).forEach(iterFn);\n      return element;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(element, o) {\n      if (element) {\n        var iterFn = function iterFn(cKey) {\n          var callback = o[cKey];\n\n          var eventIterFn = function eventIterFn(event) {\n            element.addEventListener(event, callback);\n          };\n\n          cKey.split(/\\s+/).forEach(eventIterFn);\n        };\n\n        Object.keys(o).forEach(iterFn);\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(element, o) {\n      if (element) {\n        var iterFn = function iterFn(cKey) {\n          var callback = o[cKey];\n\n          var eventIterFn = function eventIterFn(event) {\n            element.removeEventListener(event, callback);\n          };\n\n          cKey.split(/\\s+/).forEach(eventIterFn);\n        };\n\n        Object.keys(o).forEach(iterFn);\n      }\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(target, type, properties) {\n      var evt = document.createEvent('HTMLEvents');\n\n      var iterFn = function iterFn(j) {\n        evt[j] = properties[j];\n      };\n\n      evt.initEvent(type, true, true);\n\n      if (_typeof(properties) === 'object') {\n        Object.keys(properties).forEach(iterFn);\n      }\n\n      return target.dispatchEvent(evt);\n    }\n  }, {\n    key: \"regExpEscape\",\n    value: function regExpEscape(s) {\n      return s.replace(/[-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n  }, {\n    key: \"siblingIndex\",\n    value: function siblingIndex(el) {\n      var i = 0;\n      var testEl = el;\n\n      while (testEl) {\n        testEl = testEl.previousElementSibling;\n        i += 1;\n      }\n\n      return i;\n    }\n  }]);\n\n  return Awesomplete;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL0F3ZXNvbXBsZXRlLy4vc3JjL2pzL2F3ZXNvbXBsZXRlLmpzP2M0MTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0LCB1c2FibGUgbG9jYWwgYXV0b2NvbXBsZXRlIGxpYnJhcnkgZm9yIG1vZGVybiBicm93c2Vyc1xuICogQmVjYXVzZSB0aGVyZSB3ZXJlbuKAmXQgZW5vdWdoIGF1dG9jb21wbGV0ZSBzY3JpcHRzIGluIHRoZSB3b3JsZD9cbiAqIEJlY2F1c2UgSeKAmW0gY29tcGxldGVseSBpbnNhbmUgYW5kIGhhdmUgTklIIHN5bmRyb21lPyBQcm9iYWJseSBib3RoLiA6UFxuICogQGF1dGhvciBMZWEgVmVyb3UgaHR0cDovL2xlYXZlcm91LmdpdGh1Yi5pby9hd2Vzb21wbGV0ZVxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc2luZ2xlIFN1Z2dlc3N0aW9uLiAqL1xuY2xhc3MgU3VnZ2VzdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBsZXQgbyA9IHsgbGFiZWw6ICdVbmtub3duIGRhdGEnLCB2YWx1ZTogJ1Vua25vd24gZGF0YScgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbyA9IHsgbGFiZWw6IGRhdGEsIHZhbHVlOiBkYXRhIH07XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgbyA9IHsgbGFiZWw6IGRhdGFbMF0sIHZhbHVlOiBkYXRhWzFdIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICgnbGFiZWwnIGluIGRhdGEgfHwgJ3ZhbHVlJyBpbiBkYXRhKSkge1xuICAgICAgICAgICAgbyA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhYmVsID0gby5sYWJlbCB8fCBvLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gby52YWx1ZTtcblxuICAgICAgICBpZiAoJ3VzZXJEYXRhJyBpbiBvKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJEYXRhID0gby51c2VyRGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFiZWx9YDtcbiAgICB9XG5cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbn1cblxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBBd2Vzb21wbGV0ZS4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF3ZXNvbXBsZXRlIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCwgbykge1xuICAgICAgICBBd2Vzb21wbGV0ZS5hbGwgPSBbXTtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgbnVtYmVyIG9mIGluc3RhbmNlcyBmb3IgdW5pcXVlIElEc1xuICAgICAgICBBd2Vzb21wbGV0ZS5jb3VudCA9IChBd2Vzb21wbGV0ZS5jb3VudCB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMuY291bnQgPSBBd2Vzb21wbGV0ZS5jb3VudDtcblxuICAgICAgICAvLyBTZXR1cFxuICAgICAgICB0aGlzLmlzT3BlbmVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5pbnB1dCA9IEF3ZXNvbXBsZXRlLnF1ZXJ5KGlucHV0KTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsICdvZmYnKTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtb3ducycsIGBhd2Vzb21wbGV0ZV9saXN0XyR7dGhpcy5jb3VudH1gKTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnY29tYm9ib3gnKTtcblxuICAgICAgICAvLyBzdG9yZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2Ugd2UgbmVlZCB0byBkaXN0aW5ndWlzaFxuICAgICAgICAvLyBiZXR3ZWVuIGRlZmF1bHQgYW5kIGN1c3RvbWl6ZWQgYmVoYXZpb3IgbGF0ZXIgb25cbiAgICAgICAgdGhpcy5vcHRpb25zID0gbyB8fCB7fTtcblxuICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBtaW5DaGFyczogMixcbiAgICAgICAgICAgIG1heEl0ZW1zOiAxMCxcbiAgICAgICAgICAgIGF1dG9GaXJzdDogZmFsc2UsXG4gICAgICAgICAgICBkYXRhOiBBd2Vzb21wbGV0ZS5EQVRBLFxuICAgICAgICAgICAgZmlsdGVyOiBBd2Vzb21wbGV0ZS5GSUxURVJfQ09OVEFJTlMsXG4gICAgICAgICAgICBzb3J0OiBvLnNvcnQgPT09IGZhbHNlID8gZmFsc2UgOiBBd2Vzb21wbGV0ZS5TT1JUX0JZTEVOR1RILFxuICAgICAgICAgICAgY29udGFpbmVyOiBBd2Vzb21wbGV0ZS5DT05UQUlORVIsXG4gICAgICAgICAgICBpdGVtOiBBd2Vzb21wbGV0ZS5JVEVNLFxuICAgICAgICAgICAgcmVwbGFjZTogQXdlc29tcGxldGUuUkVQTEFDRSxcbiAgICAgICAgICAgIHRhYlNlbGVjdDogZmFsc2UsXG4gICAgICAgIH0sIG8pO1xuXG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcblxuICAgICAgICAvLyBDcmVhdGUgbmVjZXNzYXJ5IGVsZW1lbnRzXG5cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcihpbnB1dCk7XG5cbiAgICAgICAgdGhpcy51bCA9IEF3ZXNvbXBsZXRlLmNyZWF0ZSgndWwnLCB7XG4gICAgICAgICAgICBoaWRkZW46ICdoaWRkZW4nLFxuICAgICAgICAgICAgcm9sZTogJ2xpc3Rib3gnLFxuICAgICAgICAgICAgaWQ6IGBhd2Vzb21wbGV0ZV9saXN0XyR7dGhpcy5jb3VudH1gLFxuICAgICAgICAgICAgaW5zaWRlOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBBd2Vzb21wbGV0ZS5jcmVhdGUoJ3NwYW4nLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICd2aXN1YWxseS1oaWRkZW4nLFxuICAgICAgICAgICAgcm9sZTogJ3N0YXR1cycsXG4gICAgICAgICAgICAnYXJpYS1saXZlJzogJ2Fzc2VydGl2ZScsXG4gICAgICAgICAgICAnYXJpYS1hdG9taWMnOiB0cnVlLFxuICAgICAgICAgICAgaW5zaWRlOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgIHRleHRDb250ZW50OiB0aGlzLm1pbkNoYXJzICE9PSAwID8gKGBUeXBlICR7dGhpcy5taW5DaGFyc30gb3IgbW9yZSBjaGFyYWN0ZXJzIGZvciByZXN1bHRzLmApIDogJ0JlZ2luIHR5cGluZyBmb3IgcmVzdWx0cy4nLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBCaW5kIGV2ZW50c1xuXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5ldmFsdWF0ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIGJsdXI6IHRoaXMuY2xvc2UuYmluZCh0aGlzLCB7IHJlYXNvbjogJ2JsdXInIH0pLFxuICAgICAgICAgICAgICAgIGtleWRvd24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBldnQua2V5Q29kZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZHJvcGRvd24gYHVsYCBpcyBpbiB2aWV3LCB0aGVuIGFjdCBvbiBrZXlkb3duIGZvciB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICAgICAgICAgICAgICAgIC8vIEVudGVyIC8gRXNjIC8gVXAgLyBEb3duXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAxMyAmJiBtZS5zZWxlY3RlZCkgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSA5ICYmIG1lLnNlbGVjdGVkICYmIG1lLnRhYlNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSAyNykgeyAvLyBFc2NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5jbG9zZSh7IHJlYXNvbjogJ2VzYycgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDM4IHx8IGMgPT09IDQwKSB7IC8vIERvd24vVXAgYXJyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtjID09PSAzOCA/ICdwcmV2aW91cycgOiAnbmV4dCddKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm06IHtcbiAgICAgICAgICAgICAgICBzdWJtaXQ6IHRoaXMuY2xvc2UuYmluZCh0aGlzLCB7IHJlYXNvbjogJ3N1Ym1pdCcgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdWw6IHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IG1vdXNlZG93bSwgd2hpY2ggZW5zdXJlcyB0aGUgaW5wdXQgaXMgbm90IGJsdXJyZWQuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBzZWxlY3Rpb24gd2lsbCBoYXBwZW4gb24gY2xpY2suIFRoaXMgYWxzbyBlbnN1cmVzIGRyYWdnaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIGN1cnNvciBhd2F5IGZyb20gdGhlIGxpc3QgaXRlbSB3aWxsIGNhbmNlbCB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgbW91c2Vkb3duKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkIGV2ZW4gaWYgdGhlIGNvcnJlc3BvbmRpbmcgbW91c2Vkb3duIGV2ZW50IGhhcyBjYWxsZWRcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgICAgICAgIGNsaWNrKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGkgPSBldnQudGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaSAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxpICYmICEvbGkvaS50ZXN0KGxpLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpID0gbGkucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpICYmIGV2dC5idXR0b24gPT09IDApIHsgLy8gT25seSBzZWxlY3Qgb24gbGVmdCBjbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNlbGVjdChsaSwgZXZ0LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBBd2Vzb21wbGV0ZS5iaW5kKHRoaXMuaW5wdXQsIHRoaXMuZXZlbnRzLmlucHV0KTtcbiAgICAgICAgQXdlc29tcGxldGUuYmluZCh0aGlzLmlucHV0LmZvcm0sIHRoaXMuZXZlbnRzLmZvcm0pO1xuICAgICAgICBBd2Vzb21wbGV0ZS5iaW5kKHRoaXMudWwsIHRoaXMuZXZlbnRzLnVsKTtcblxuICAgICAgICBpZiAodGhpcy5pbnB1dC5oYXNBdHRyaWJ1dGUoJ2xpc3QnKSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ID0gYCMke3RoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdsaXN0Jyl9YDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdsaXN0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1saXN0JykgfHwgby5saXN0IHx8IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgQXdlc29tcGxldGUuYWxsLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgY29uZmlndXJlKHByb3BlcnRpZXMsIG8pIHtcbiAgICAgICAgY29uc3QgaXRlckZuID0gKGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWwgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgYXR0clZhbHVlID0gdGhpcy5pbnB1dC5nZXRBdHRyaWJ1dGUoYGRhdGEtJHtpLnRvTG93ZXJDYXNlKCl9YCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcGFyc2VJbnQoYXR0clZhbHVlLCAxMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluaXRpYWwgPT09IGZhbHNlKSB7IC8vIEJvb2xlYW4gb3B0aW9ucyBtdXN0IGJlIGZhbHNlIGJ5IGRlZmF1bHQgYW55d2F5XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IGF0dHJWYWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBhdHRyVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpc1tpXSAmJiB0aGlzW2ldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IChpIGluIG8pID8gb1tpXSA6IGluaXRpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goaXRlckZuKTtcbiAgICB9XG5cbiAgICBzZXQgbGlzdChsaXN0KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMaXN0ID0gbGlzdDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycgJiYgbGlzdC5pbmRleE9mKCcsJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhTGlzdCA9IGxpc3Quc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgICB9IGVsc2UgeyAvLyBFbGVtZW50IG9yIENTUyBzZWxlY3RvclxuICAgICAgICAgICAgY29uc3QgcXVlcmllZExpc3QgPSBBd2Vzb21wbGV0ZS5xdWVyeShsaXN0KTtcblxuICAgICAgICAgICAgaWYgKHF1ZXJpZWRMaXN0ICYmIHF1ZXJpZWRMaXN0LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZWwudGV4dENvbnRlbnQudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbC52YWx1ZSB8fCB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBlbC5sYWJlbCB8fCB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goeyBsYWJlbCwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShxdWVyaWVkTGlzdC5jaGlsZHJlbikuZm9yRWFjaChmbik7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhTGlzdCA9IGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTGlzdDtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID4gLTE7XG4gICAgfVxuXG4gICAgZ2V0IG9wZW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPcGVuZWQ7XG4gICAgfVxuXG4gICAgY2xvc2Uobykge1xuICAgICAgICBpZiAoIXRoaXMub3BlbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVsLnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJycpO1xuICAgICAgICB0aGlzLmlzT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcblxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICcnKTtcblxuICAgICAgICBBd2Vzb21wbGV0ZS5maXJlKHRoaXMuaW5wdXQsICdhd2Vzb21wbGV0ZS1jbG9zZScsIG8gfHwge30pO1xuICAgIH1cblxuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMudWwucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgICAgdGhpcy5pc09wZW5lZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5zdGF0dXMucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcblxuICAgICAgICBpZiAodGhpcy5hdXRvRmlyc3QgJiYgdGhpcy5pbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZ290bygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEF3ZXNvbXBsZXRlLmZpcmUodGhpcy5pbnB1dCwgJ2F3ZXNvbXBsZXRlLW9wZW4nKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyByZW1vdmUgZXZlbnRzIGZyb20gdGhlIGlucHV0IGFuZCBpdHMgZm9ybVxuICAgICAgICBBd2Vzb21wbGV0ZS51bmJpbmQodGhpcy5pbnB1dCwgdGhpcy5ldmVudHMuaW5wdXQpO1xuICAgICAgICBBd2Vzb21wbGV0ZS51bmJpbmQodGhpcy5pbnB1dC5mb3JtLCB0aGlzLmV2ZW50cy5mb3JtKTtcblxuICAgICAgICAvLyBjbGVhbnVwIGNvbnRhaW5lciBpZiBpdCB3YXMgY3JlYXRlZCBieSBBd2Vzb21wbGV0ZSBidXQgbGVhdmUgaXQgYWxvbmUgb3RoZXJ3aXNlXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gbW92ZSB0aGUgaW5wdXQgb3V0IG9mIHRoZSBhd2Vzb21wbGV0ZSBjb250YWluZXIgYW5kIHJlbW92ZSB0aGUgY29udGFpbmVyIGFuZFxuICAgICAgICAgICAgLy8gaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICBjb25zdCB7IHBhcmVudE5vZGUgfSA9IHRoaXMuY29udGFpbmVyO1xuXG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmlucHV0LCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBhdXRvY29tcGxldGUgYW5kIGFyaWEtYXV0b2NvbXBsZXRlIGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScpO1xuICAgICAgICB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1hdXRvY29tcGxldGUnKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhpcyBhd2Vzb21lcGxldGUgaW5zdGFuY2UgZnJvbSB0aGUgZ2xvYmFsIGFycmF5IG9mIGluc3RhbmNlc1xuICAgICAgICBjb25zdCBpbmRleE9mQXdlc29tcGxldGUgPSBBd2Vzb21wbGV0ZS5hbGwuaW5kZXhPZih0aGlzKTtcblxuICAgICAgICBpZiAoaW5kZXhPZkF3ZXNvbXBsZXRlICE9PSAtMSkge1xuICAgICAgICAgICAgQXdlc29tcGxldGUuYWxsLnNwbGljZShpbmRleE9mQXdlc29tcGxldGUsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLnVsLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBjb3VudCAtIDEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nb3RvKGluZGV4KTtcbiAgICB9XG5cbiAgICBwcmV2aW91cygpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLnVsLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5pbmRleCAtIDE7XG5cbiAgICAgICAgdGhpcy5nb3RvKHRoaXMuc2VsZWN0ZWQgJiYgcG9zICE9PSAtMSA/IHBvcyA6IGNvdW50IC0gMSk7XG4gICAgfVxuXG4gICAgLy8gU2hvdWxkIG5vdCBiZSB1c2VkLCBoaWdobGlnaHRzIHNwZWNpZmljIGl0ZW0gd2l0aG91dCBhbnkgY2hlY2tzIVxuICAgIGdvdG8oaSkge1xuICAgICAgICBjb25zdCBsaXMgPSB0aGlzLnVsLmNoaWxkcmVuO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBsaXNbdGhpcy5pbmRleF0uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluZGV4ID0gaTtcblxuICAgICAgICBpZiAoaSA+IC0xICYmIGxpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsaXNbaV0uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcblxuICAgICAgICAgICAgdGhpcy5zdGF0dXMudGV4dENvbnRlbnQgPSBgJHtsaXNbaV0udGV4dENvbnRlbnR9LCBsaXN0IGl0ZW0gJHsoaSArIDEpfSBvZiAke2xpcy5sZW5ndGh9YDtcblxuICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGAke3RoaXMudWwuaWR9X2l0ZW1fJHt0aGlzLmluZGV4fWApO1xuXG4gICAgICAgICAgICAvLyBzY3JvbGwgdG8gaGlnaGxpZ2h0ZWQgZWxlbWVudCBpbiBjYXNlIHBhcmVudCdzIGhlaWdodCBpcyBmaXhlZFxuICAgICAgICAgICAgdGhpcy51bC5zY3JvbGxUb3AgPSBsaXNbaV0ub2Zmc2V0VG9wIC0gdGhpcy51bC5jbGllbnRIZWlnaHQgKyBsaXNbaV0uY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgICAgICBBd2Vzb21wbGV0ZS5maXJlKHRoaXMuaW5wdXQsICdhd2Vzb21wbGV0ZS1oaWdobGlnaHQnLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5zdWdnZXN0aW9uc1t0aGlzLmluZGV4XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0KHNlbGVjdGVkLCBvcmlnaW4pIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkO1xuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBBd2Vzb21wbGV0ZS5zaWJsaW5nSW5kZXgoc2VsZWN0ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0ZWRJdGVtID0gdGhpcy51bC5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSB0aGlzLnN1Z2dlc3Rpb25zW3RoaXMuaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgICAgIGNvbnN0IGFsbG93ZWQgPSBBd2Vzb21wbGV0ZS5maXJlKHRoaXMuaW5wdXQsICdhd2Vzb21wbGV0ZS1zZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogYCR7c3VnZ2VzdGlvbn1gLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRTdWdnZXN0aW9uOiBzdWdnZXN0aW9uLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luIHx8IHNlbGVjdGVkSXRlbSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZShzdWdnZXN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKHsgcmVhc29uOiAnc2VsZWN0JyB9KTtcbiAgICAgICAgICAgICAgICBBd2Vzb21wbGV0ZS5maXJlKHRoaXMuaW5wdXQsICdhd2Vzb21wbGV0ZS1zZWxlY3Rjb21wbGV0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYCR7c3VnZ2VzdGlvbn1gLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFN1Z2dlc3Rpb246IHN1Z2dlc3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBldmFsdWF0ZSgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLmlucHV0O1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gdGhpcy5taW5DaGFycyAmJiB0aGlzLmRhdGFMaXN0ICYmIHRoaXMuZGF0YUxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbGlzdCB3aXRoIG9wdGlvbnMgdGhhdCBtYXRjaFxuICAgICAgICAgICAgdGhpcy51bC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgY29uc3QgbWFwRm4gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3VnZ2VzdGlvbihtZS5kYXRhKGl0ZW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZS5maWx0ZXIoaXRlbSwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGlvbnMgPSB0aGlzLmRhdGFMaXN0XG4gICAgICAgICAgICAgICAgLm1hcChtYXBGbilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZpbHRlckZuKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc29ydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Z2dlc3Rpb25zID0gdGhpcy5zdWdnZXN0aW9ucy5zb3J0KHRoaXMuc29ydCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGlvbnMgPSB0aGlzLnN1Z2dlc3Rpb25zLnNsaWNlKDAsIHRoaXMubWF4SXRlbXMpO1xuXG4gICAgICAgICAgICBjb25zdCBhcHBlbmRGbiA9IGZ1bmN0aW9uICh0ZXh0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIG1lLnVsLmFwcGVuZENoaWxkKG1lLml0ZW0odGV4dCwgdmFsdWUsIGluZGV4KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdWdnZXN0aW9ucy5mb3JFYWNoKGFwcGVuZEZuKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudWwuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMudGV4dENvbnRlbnQgPSAnTm8gcmVzdWx0cyBmb3VuZCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKHsgcmVhc29uOiAnbm9tYXRjaGVzJyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cy50ZXh0Q29udGVudCA9IGAke3RoaXMudWwuY2hpbGRyZW4ubGVuZ3RofSByZXN1bHRzIGZvdW5kYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoeyByZWFzb246ICdub21hdGNoZXMnIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXR1cy50ZXh0Q29udGVudCA9ICdObyByZXN1bHRzIGZvdW5kJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hcms6IFN0YXRpYyBtZXRob2RzL3Byb3BlcnRpZXNcblxuICAgIHN0YXRpYyBGSUxURVJfQ09OVEFJTlModGV4dCwgaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIFJlZ0V4cChBd2Vzb21wbGV0ZS5yZWdFeHBFc2NhcGUoaW5wdXQudHJpbSgpKSwgJ2knKS50ZXN0KHRleHQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBGSUxURVJfU1RBUlRTV0lUSCh0ZXh0LCBpbnB1dCkge1xuICAgICAgICByZXR1cm4gUmVnRXhwKGBeJHtBd2Vzb21wbGV0ZS5yZWdFeHBFc2NhcGUoaW5wdXQudHJpbSgpKX1gLCAnaScpLnRlc3QodGV4dCk7XG4gICAgfVxuXG4gICAgc3RhdGljIFNPUlRfQllMRU5HVEgoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgQ09OVEFJTkVSKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBd2Vzb21wbGV0ZS5jcmVhdGUoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2F3ZXNvbXBsZXRlJyxcbiAgICAgICAgICAgIGFyb3VuZDogaW5wdXQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBJVEVNKHRleHQsIGlucHV0LCBpdGVtSWQpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IGlucHV0LnRyaW0oKSA9PT0gJycgPyB0ZXh0IDogKGAke3RleHR9YCkucmVwbGFjZShSZWdFeHAoQXdlc29tcGxldGUucmVnRXhwRXNjYXBlKGlucHV0LnRyaW0oKSksICdnaScpLCAnPG1hcms+JCY8L21hcms+Jyk7XG4gICAgICAgIHJldHVybiBBd2Vzb21wbGV0ZS5jcmVhdGUoJ2xpJywge1xuICAgICAgICAgICAgaW5uZXJIVE1MOiBodG1sLFxuICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiAnZmFsc2UnLFxuICAgICAgICAgICAgaWQ6IGBhd2Vzb21wbGV0ZV9saXN0XyR7dGhpcy5jb3VudH1faXRlbV8ke2l0ZW1JZH1gLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgUkVQTEFDRSh0ZXh0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB0ZXh0LnZhbHVlIHx8IHRleHQubGFiZWw7XG4gICAgfVxuXG4gICAgc3RhdGljIERBVEEoaXRlbS8qICwgaW5wdXQgKi8pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLy8gSGVscGVyc1xuXG4gICAgc3RhdGljIHF1ZXJ5KGV4cHIsIGNvbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGV4cHIgPT09ICdzdHJpbmcnID8gKGNvbiB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvcihleHByKSA6IGV4cHIgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBzdGF0aWMgcXVlcnlBbGwoZXhwciwgY29uKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCgoY29uIHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKGV4cHIpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKHRhZywgbykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBjb25zdCBpdGVyRm4gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gb1tpXTtcblxuICAgICAgICAgICAgaWYgKGkgPT09ICdpbnNpZGUnKSB7XG4gICAgICAgICAgICAgICAgQXdlc29tcGxldGUucXVlcnkodmFsKS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gJ2Fyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBBd2Vzb21wbGV0ZS5xdWVyeSh2YWwpO1xuICAgICAgICAgICAgICAgIHJlZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCByZWYpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQocmVmKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWYuZ2V0QXR0cmlidXRlKCdhdXRvZm9jdXMnKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFtpXSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoaSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChpdGVyRm4pO1xuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHN0YXRpYyBiaW5kKGVsZW1lbnQsIG8pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJGbiA9IGZ1bmN0aW9uIChjS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBvW2NLZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50SXRlckZuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY0tleS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZXZlbnRJdGVyRm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goaXRlckZuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1bmJpbmQoZWxlbWVudCwgbykge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgaXRlckZuID0gZnVuY3Rpb24gKGNLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IG9bY0tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRJdGVyRm4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjS2V5LnNwbGl0KC9cXHMrLykuZm9yRWFjaChldmVudEl0ZXJGbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChpdGVyRm4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGZpcmUodGFyZ2V0LCB0eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICAgIGNvbnN0IGl0ZXJGbiA9IGZ1bmN0aW9uIChqKSB7XG4gICAgICAgICAgICBldnRbal0gPSBwcm9wZXJ0aWVzW2pdO1xuICAgICAgICB9O1xuICAgICAgICBldnQuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGl0ZXJGbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVnRXhwRXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNpYmxpbmdJbmRleChlbCkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCB0ZXN0RWwgPSBlbDtcbiAgICAgICAgd2hpbGUgKHRlc3RFbCkge1xuICAgICAgICAgICAgdGVzdEVsID0gdGVzdEVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUtBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFWQTtBQUNBO0FBQ0E7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBREE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFhQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBdUJBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUEzQkE7QUFzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUExTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBcUxBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}])});